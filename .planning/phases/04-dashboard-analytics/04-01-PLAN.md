---
phase: 04-dashboard-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260220000000_session_summaries.sql
  - src/types/database.ts
  - src/lib/quiz/answers.ts
  - src/lib/dashboard/recommendations.ts
  - src/pages/SessionSummary.tsx
  - src/App.tsx
autonomous: true
requirements: [COMP-02, COMP-03, COMP-04, COMP-05]

must_haves:
  truths:
    - "After quiz completion, user is routed to /session/:sessionId/summary instead of /dashboard directly"
    - "Session summary page shows the final score (0-100) computed from completed quiz_answers"
    - "Session summary shows per-topic score breakdown with topic name and average score per topic"
    - "Session summary shows a recommended next difficulty level (beginner/normal/advanced) based on final score thresholds"
    - "A 'Back to Dashboard' button navigates to /dashboard"
    - "A session_summaries row is inserted in Supabase when a quiz session is completed"
  artifacts:
    - path: "supabase/migrations/20260220000000_session_summaries.sql"
      provides: "session_summaries table with indexes and RLS"
      contains: "CREATE TABLE session_summaries"
    - path: "src/types/database.ts"
      provides: "SessionSummaryRow TypeScript type"
      contains: "session_summaries"
    - path: "src/lib/dashboard/recommendations.ts"
      provides: "computeSessionSummary() pure function"
      exports: ["computeSessionSummary"]
    - path: "src/pages/SessionSummary.tsx"
      provides: "Post-quiz summary page rendering score, topic breakdown, recommendation"
      min_lines: 80
    - path: "src/lib/quiz/answers.ts"
      provides: "Updated completeQuizSession() that also inserts session_summaries row"
      contains: "session_summaries"
  key_links:
    - from: "src/pages/QuizSession.tsx"
      to: "/session/:sessionId/summary"
      via: "navigate() in isSessionComplete useEffect"
      pattern: "navigate.*summary"
    - from: "src/lib/quiz/answers.ts"
      to: "supabase.from('session_summaries')"
      via: "completeQuizSession() extended with summary insert"
      pattern: "session_summaries"
    - from: "src/pages/SessionSummary.tsx"
      to: "/dashboard"
      via: "Link or navigate button"
      pattern: "dashboard"
---

<objective>
Create the session_summaries database table, update completeQuizSession() to populate it, implement the computeSessionSummary() logic (final score, topic breakdown, difficulty recommendation), and build the SessionSummaryPage that users land on after completing a quiz.

Purpose: Closes the quiz loop — users currently land on /dashboard after a session with no feedback. This plan surfaces the session outcome with score, topic breakdown, and a recommendation before they return to the dashboard.
Output: Supabase migration, updated TypeScript types, computeSessionSummary() pure function, SessionSummaryPage, updated router.
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dashboard-analytics/04-RESEARCH.md
@src/types/database.ts
@src/lib/quiz/answers.ts
@src/pages/QuizSession.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: session_summaries migration + TypeScript types + computeSessionSummary()</name>
  <files>
    supabase/migrations/20260220000000_session_summaries.sql
    src/types/database.ts
    src/lib/dashboard/recommendations.ts
  </files>
  <action>
    **Migration (supabase/migrations/20260220000000_session_summaries.sql):**

    Create the denormalized session_summaries table (ROADMAP-recommended for fast dashboard reads):

    ```sql
    CREATE TABLE IF NOT EXISTS public.session_summaries (
      session_id    UUID PRIMARY KEY REFERENCES public.quiz_sessions(id) ON DELETE CASCADE,
      user_id       UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
      topics        TEXT[] NOT NULL DEFAULT '{}',
      difficulty    TEXT NOT NULL,
      question_count INT NOT NULL,
      final_score   INT NOT NULL,
      num_completed INT NOT NULL,
      num_skipped   INT NOT NULL,
      duration_seconds INT,
      created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- RLS: users can only see their own summaries
    ALTER TABLE public.session_summaries ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Users can view own session summaries"
      ON public.session_summaries FOR SELECT
      USING ((SELECT auth.uid()) = user_id);
    CREATE POLICY "Users can insert own session summaries"
      ON public.session_summaries FOR INSERT
      WITH CHECK ((SELECT auth.uid()) = user_id);

    -- Indexes for fast dashboard filtering
    CREATE INDEX idx_session_summaries_user_id ON public.session_summaries(user_id);
    CREATE INDEX idx_session_summaries_user_created ON public.session_summaries(user_id, created_at DESC);
    ```

    Apply the migration: `npx supabase db push` or apply via Supabase dashboard SQL editor.

    **TypeScript types (src/types/database.ts):**

    Add `session_summaries` table to the existing `Database` interface, following the same shape pattern as quiz_answers. Add to `Tables`:

    ```typescript
    session_summaries: {
      Row: {
        session_id: string
        user_id: string
        topics: string[]
        difficulty: 'beginner' | 'normal' | 'advanced'
        question_count: number
        final_score: number
        num_completed: number
        num_skipped: number
        duration_seconds: number | null
        created_at: string
      }
      Insert: {
        session_id: string
        user_id: string
        topics: string[]
        difficulty: 'beginner' | 'normal' | 'advanced'
        question_count: number
        final_score: number
        num_completed: number
        num_skipped: number
        duration_seconds?: number | null
        created_at?: string
      }
      Update: {
        final_score?: number
        num_completed?: number
        num_skipped?: number
        duration_seconds?: number | null
      }
      Relationships: []
    }
    ```

    Add convenience alias at the bottom of database.ts:
    ```typescript
    export type SessionSummaryRow = Database['public']['Tables']['session_summaries']['Row']
    export type SessionSummaryInsert = Database['public']['Tables']['session_summaries']['Insert']
    ```

    **Pure compute function (src/lib/dashboard/recommendations.ts):**

    Create this new file. It contains only pure functions with no Supabase dependency:

    ```typescript
    // src/lib/dashboard/recommendations.ts
    // Pure functions for computing session summary and difficulty recommendations.
    // No Supabase dependency — takes data already loaded and returns computed values.
    import type { QuizAnswerRow, QuizSessionRow } from '../types/database'

    export interface TopicBreakdown {
      topic: string
      avgScore: number
      count: number
    }

    export interface SessionSummaryResult {
      finalScore: number
      numCompleted: number
      numSkipped: number
      topicBreakdown: TopicBreakdown[]
      recommendedDifficulty: 'beginner' | 'normal' | 'advanced'
    }

    // computeSessionSummary: derive final score, per-topic breakdown, and recommended difficulty.
    // Scoring rules: avg >= 85 → upgrade difficulty; < 50 → downgrade; 50-84 → stay.
    export function computeSessionSummary(
      answers: QuizAnswerRow[],
      session: QuizSessionRow
    ): SessionSummaryResult {
      const completed = answers.filter(a => a.status === 'completed')
      const skipped = answers.filter(a => a.status === 'skipped')

      const finalScore =
        completed.length > 0
          ? Math.round(completed.reduce((sum, a) => sum + (a.score ?? 0), 0) / completed.length)
          : 0

      // Group completed answers by topic from quiz_questions (topic on quiz_answers is null — must join via quiz_questions)
      // quiz_answers does NOT have a topic column; we use question_index to correlate with questions array.
      // Since we don't have the questions array here, we'll compute the topic join in the page component.
      // This function receives { topic, score }[] pairs pre-grouped by the caller for flexibility.
      const scoreByTopic: Record<string, { sum: number; count: number }> = {}
      completed.forEach(answer => {
        // topic will be injected by caller via enriched answers
        const topic = (answer as QuizAnswerRow & { _topic?: string })._topic ?? 'Unknown'
        if (!scoreByTopic[topic]) scoreByTopic[topic] = { sum: 0, count: 0 }
        scoreByTopic[topic].sum += answer.score ?? 0
        scoreByTopic[topic].count += 1
      })

      const topicBreakdown: TopicBreakdown[] = Object.entries(scoreByTopic)
        .map(([topic, { sum, count }]) => ({
          topic,
          avgScore: Math.round(sum / count),
          count
        }))
        .sort((a, b) => b.avgScore - a.avgScore)

      // Difficulty recommendation
      const currentDifficulty = session.difficulty
      let recommendedDifficulty: 'beginner' | 'normal' | 'advanced' = currentDifficulty
      if (finalScore >= 85) {
        if (currentDifficulty === 'beginner') recommendedDifficulty = 'normal'
        else if (currentDifficulty === 'normal') recommendedDifficulty = 'advanced'
        // already 'advanced' → stay
      } else if (finalScore < 50) {
        if (currentDifficulty === 'advanced') recommendedDifficulty = 'normal'
        else if (currentDifficulty === 'normal') recommendedDifficulty = 'beginner'
        // already 'beginner' → stay
      }

      return {
        finalScore,
        numCompleted: completed.length,
        numSkipped: skipped.length,
        topicBreakdown,
        recommendedDifficulty
      }
    }

    // getScoreColor: consistent color tiers established in Phase 3 (>=85 green, >=70 blue, >=50 yellow, <50 red)
    export function getScoreColor(score: number): string {
      if (score >= 85) return 'text-green-600'
      if (score >= 70) return 'text-blue-600'
      if (score >= 50) return 'text-yellow-600'
      return 'text-red-600'
    }

    export function getScoreBgColor(score: number): string {
      if (score >= 85) return 'bg-green-100 border-green-200'
      if (score >= 70) return 'bg-blue-100 border-blue-200'
      if (score >= 50) return 'bg-yellow-100 border-yellow-200'
      return 'bg-red-100 border-red-200'
    }
    ```

    Note on topic join: quiz_answers does not store topic. The topic must come from quiz_questions. The SessionSummaryPage (Task 2) will do a joined Supabase query to enrich answers with their topic before calling computeSessionSummary.
  </action>
  <verify>
    Run: `npx tsc -p tsconfig.app.json --noEmit` — 0 errors.
    Check: `src/lib/dashboard/recommendations.ts` exports `computeSessionSummary`, `getScoreColor`, `getScoreBgColor`.
    Check: `src/types/database.ts` contains `session_summaries` table definition and `SessionSummaryRow` export.
    Check: Migration file exists at `supabase/migrations/20260220000000_session_summaries.sql` with CREATE TABLE and RLS policies.
  </verify>
  <done>
    TypeScript compiles clean. `SessionSummaryRow` type available. `computeSessionSummary()` exported from recommendations.ts. Migration file ready to apply.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update completeQuizSession(), SessionSummaryPage, and router</name>
  <files>
    src/lib/quiz/answers.ts
    src/pages/SessionSummary.tsx
    src/App.tsx
  </files>
  <action>
    **Update completeQuizSession() in src/lib/quiz/answers.ts:**

    Extend the existing function to also fetch session details and answers, then insert a session_summaries row. Use explicit insert (not trigger) for reliability per RESEARCH.md recommendation.

    Replace the current `completeQuizSession` function with:

    ```typescript
    // Mark session complete AND insert denormalized session_summaries row for fast dashboard reads.
    // Explicit insert (not trigger) per Phase 4 research recommendation — safer for v1.
    export async function completeQuizSession(sessionId: string): Promise<void> {
      // 1. Fetch the session row (for user_id, topics, difficulty, question_count, created_at)
      const { data: sessionRow, error: sessionError } = await supabase
        .from('quiz_sessions')
        .select('*')
        .eq('id', sessionId)
        .single()

      if (sessionError || !sessionRow) {
        throw new Error(`Failed to fetch session for completion: ${sessionError?.message}`)
      }

      // 2. Mark session as completed
      const { error: updateError } = await supabase
        .from('quiz_sessions')
        .update({ status: 'completed' as const })
        .eq('id', sessionId)

      if (updateError) throw new Error(`Failed to complete quiz session: ${updateError.message}`)

      // 3. Fetch all answers for the session to compute aggregates
      const { data: answers, error: answersError } = await supabase
        .from('quiz_answers')
        .select('score, status')
        .eq('session_id', sessionId)

      if (answersError) throw new Error(`Failed to fetch answers for summary: ${answersError.message}`)

      const answerRows = answers ?? []
      const completed = answerRows.filter(a => a.status === 'completed')
      const skipped = answerRows.filter(a => a.status === 'skipped')
      const finalScore =
        completed.length > 0
          ? Math.round(completed.reduce((sum, a) => sum + (a.score ?? 0), 0) / completed.length)
          : 0

      const durationSeconds = Math.floor(
        (Date.now() - new Date(sessionRow.created_at).getTime()) / 1000
      )

      // 4. Insert session_summaries row (upsert to avoid duplicate on double-fire)
      const { error: summaryError } = await supabase
        .from('session_summaries')
        .upsert({
          session_id: sessionId,
          user_id: sessionRow.user_id,
          topics: sessionRow.topics,
          difficulty: sessionRow.difficulty,
          question_count: sessionRow.question_count,
          final_score: finalScore,
          num_completed: completed.length,
          num_skipped: skipped.length,
          duration_seconds: durationSeconds,
          created_at: sessionRow.created_at
        }, { onConflict: 'session_id' })

      if (summaryError) {
        // Non-fatal: session is marked complete even if summary insert fails
        console.error(`Failed to insert session_summaries: ${summaryError.message}`)
      }
    }
    ```

    **Create SessionSummaryPage (src/pages/SessionSummary.tsx):**

    This page is routed to `/session/:sessionId/summary`. It:
    1. Reads `sessionId` from URL params.
    2. Fetches session row + quiz_questions + quiz_answers in a single join query.
    3. Enriches answers with topic from matched question.
    4. Calls `computeSessionSummary()` to get finalScore, topicBreakdown, recommendedDifficulty.
    5. Renders a clean summary card with score, topic breakdown table, recommendation, and "Back to Dashboard" button.

    ```typescript
    // src/pages/SessionSummary.tsx
    // Post-quiz session summary screen. Displays final score, topic breakdown, difficulty recommendation.
    // COMP-02: final score | COMP-03: topic breakdown | COMP-04: difficulty recommendation | COMP-05: back to dashboard
    import { useEffect, useState } from 'react'
    import { useParams, Link } from 'react-router-dom'
    import { supabase } from '../lib/supabase'
    import { computeSessionSummary, getScoreColor, getScoreBgColor } from '../lib/dashboard/recommendations'
    import type { QuizSessionRow, QuizAnswerRow, QuizQuestionRow } from '../types/database'
    import type { SessionSummaryResult } from '../lib/dashboard/recommendations'

    export default function SessionSummaryPage() {
      const { sessionId } = useParams<{ sessionId: string }>()
      const [summary, setSummary] = useState<SessionSummaryResult | null>(null)
      const [session, setSession] = useState<QuizSessionRow | null>(null)
      const [loading, setLoading] = useState(true)
      const [error, setError] = useState<string | null>(null)

      useEffect(() => {
        if (!sessionId) return

        async function load() {
          try {
            // Single join query: session + questions + answers
            const { data, error: fetchError } = await supabase
              .from('quiz_sessions')
              .select(`
                *,
                quiz_questions ( id, question_index, topic ),
                quiz_answers ( id, question_index, score, status )
              `)
              .eq('id', sessionId)
              .single()

            if (fetchError || !data) {
              setError(fetchError?.message ?? 'Session not found')
              return
            }

            const sessionRow = data as QuizSessionRow & {
              quiz_questions: Pick<QuizQuestionRow, 'id' | 'question_index' | 'topic'>[]
              quiz_answers: Pick<QuizAnswerRow, 'id' | 'question_index' | 'score' | 'status'>[]
            }

            // Build lookup: question_index → topic
            const indexToTopic = new Map<number, string>()
            sessionRow.quiz_questions.forEach(q => {
              indexToTopic.set(q.question_index, q.topic)
            })

            // Enrich answers with topic (quiz_answers has no topic column — join via question_index)
            const enrichedAnswers = sessionRow.quiz_answers.map(a => ({
              ...a,
              _topic: indexToTopic.get(a.question_index) ?? 'Unknown'
            })) as (QuizAnswerRow & { _topic: string })[]

            setSession(sessionRow as unknown as QuizSessionRow)
            setSummary(computeSessionSummary(enrichedAnswers as unknown as QuizAnswerRow[], sessionRow as unknown as QuizSessionRow))
          } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load session summary')
          } finally {
            setLoading(false)
          }
        }

        load()
      }, [sessionId])

      if (loading) {
        return (
          <div className="min-h-screen bg-gray-50 flex items-center justify-center">
            <p className="text-gray-500">Loading summary...</p>
          </div>
        )
      }

      if (error || !summary || !session) {
        return (
          <div className="min-h-screen bg-gray-50 flex items-center justify-center">
            <div className="text-center">
              <p className="text-red-600 mb-4">{error ?? 'Failed to load summary'}</p>
              <Link to="/dashboard" className="text-blue-600 underline">Back to Dashboard</Link>
            </div>
          </div>
        )
      }

      const difficultyLabel: Record<string, string> = {
        beginner: 'Beginner',
        normal: 'Intermediate',
        advanced: 'Advanced'
      }

      const sameOrUpgrade = summary.recommendedDifficulty !== session.difficulty
      const recommendationText = sameOrUpgrade
        ? `Try ${difficultyLabel[summary.recommendedDifficulty]} next — you're ready!`
        : `Stay at ${difficultyLabel[summary.recommendedDifficulty]} — keep practicing.`

      return (
        <div className="min-h-screen bg-gray-50 flex flex-col items-center justify-center py-12 px-4">
          <div className="max-w-lg w-full bg-white rounded-xl shadow-md p-8 space-y-8">
            {/* Header */}
            <div className="text-center">
              <h1 className="text-2xl font-bold text-gray-900">Quiz Complete!</h1>
              <p className="text-gray-500 mt-1">{session.topics.join(', ')} · {difficultyLabel[session.difficulty]}</p>
            </div>

            {/* Final Score (COMP-02) */}
            <div className={`rounded-lg border-2 p-6 text-center ${getScoreBgColor(summary.finalScore)}`}>
              <p className="text-sm font-medium text-gray-600 uppercase tracking-wide">Final Score</p>
              <p className={`text-6xl font-bold mt-2 ${getScoreColor(summary.finalScore)}`}>
                {summary.finalScore}
              </p>
              <p className="text-gray-500 text-sm mt-1">
                {summary.numCompleted} answered · {summary.numSkipped} skipped
              </p>
            </div>

            {/* Topic Breakdown (COMP-03) */}
            {summary.topicBreakdown.length > 0 && (
              <div>
                <h2 className="text-sm font-semibold text-gray-700 uppercase tracking-wide mb-3">
                  Score by Topic
                </h2>
                <div className="space-y-2">
                  {summary.topicBreakdown.map(({ topic, avgScore, count }) => (
                    <div key={topic} className="flex items-center justify-between py-2 border-b border-gray-100 last:border-0">
                      <span className="text-gray-700">{topic}</span>
                      <div className="flex items-center gap-2">
                        <span className="text-xs text-gray-400">{count}q</span>
                        <span className={`font-semibold w-10 text-right ${getScoreColor(avgScore)}`}>
                          {avgScore}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Difficulty Recommendation (COMP-04) */}
            <div className="bg-blue-50 border border-blue-100 rounded-lg p-4">
              <p className="text-sm font-semibold text-blue-800 mb-1">Next Session Recommendation</p>
              <p className="text-blue-700">{recommendationText}</p>
            </div>

            {/* Back to Dashboard (COMP-05) */}
            <Link
              to="/dashboard"
              className="block w-full text-center bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 rounded-lg transition-colors"
            >
              Back to Dashboard
            </Link>
          </div>
        </div>
      )
    }
    ```

    **Update App.tsx:**

    1. Import `SessionSummaryPage` from `./pages/SessionSummary`.
    2. Add a new ProtectedRoute for `/session/:sessionId/summary` before the catch-all route.
    3. Update the `isSessionComplete` navigate path in `QuizSession.tsx`: change `navigate('/dashboard')` to `navigate(\`/session/${sessionId}/summary\`)`.

    In App.tsx, add after the `/quiz/:sessionId` route:
    ```tsx
    <Route
      path="/session/:sessionId/summary"
      element={
        <ProtectedRoute>
          <SessionSummaryPage />
        </ProtectedRoute>
      }
    />
    ```

    In QuizSession.tsx, update the `isSessionComplete` useEffect navigate call:
    - Find: `navigate('/dashboard')`
    - Replace with: `navigate(\`/session/${sessionId}/summary\`)`
    (Only the navigation inside the `isSessionComplete` useEffect — not any other navigate calls.)
  </action>
  <verify>
    Run: `npx tsc -p tsconfig.app.json --noEmit` — 0 errors.
    Check: `src/pages/SessionSummary.tsx` exists with `computeSessionSummary` import.
    Check: `src/App.tsx` contains route `/session/:sessionId/summary`.
    Check: `src/pages/QuizSession.tsx` navigate call in isSessionComplete useEffect points to `/session/${sessionId}/summary`.
    Check: `src/lib/quiz/answers.ts` `completeQuizSession()` contains `session_summaries` upsert.
  </verify>
  <done>
    TypeScript compiles clean. SessionSummaryPage renders at `/session/:sessionId/summary` route. After completing a quiz, user is routed to summary page (not directly to dashboard). completeQuizSession() inserts session_summaries row. "Back to Dashboard" navigates to /dashboard.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -p tsconfig.app.json --noEmit` → 0 errors
2. Migration file `supabase/migrations/20260220000000_session_summaries.sql` exists with CREATE TABLE, RLS, indexes
3. `src/types/database.ts` contains `session_summaries` table + `SessionSummaryRow` alias
4. `src/lib/dashboard/recommendations.ts` exports `computeSessionSummary`, `getScoreColor`, `getScoreBgColor`
5. `src/pages/SessionSummary.tsx` exists and renders score + topic breakdown + recommendation + dashboard link
6. `src/App.tsx` has `/session/:sessionId/summary` ProtectedRoute
7. `src/pages/QuizSession.tsx` navigate in isSessionComplete useEffect → `/session/${sessionId}/summary`
8. `src/lib/quiz/answers.ts` `completeQuizSession()` upserts into `session_summaries`
</verification>

<success_criteria>
- After completing a quiz session, browser navigates to `/session/:sessionId/summary` (not `/dashboard`)
- Summary page displays: final score (0-100), topic breakdown with avg scores, recommended next difficulty level
- "Back to Dashboard" button on summary page navigates to `/dashboard`
- session_summaries table exists in Supabase with RLS policies (only user's own rows readable)
- completeQuizSession() populates session_summaries row on every session completion
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-dashboard-analytics/04-01-SUMMARY.md`
</output>
