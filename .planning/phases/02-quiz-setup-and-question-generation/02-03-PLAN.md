---
phase: 02-quiz-setup-and-question-generation
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/lib/quiz/questions.ts
  - src/context/QuizContext.tsx
  - src/hooks/useQuestionGeneration.ts
autonomous: true
requirements:
  - QUIZ-01
  - QUIZ-06

must_haves:
  truths:
    - "generateQuestion() validates LLM output against GeneratedQuestionSchema before returning"
    - "generateQuestion() throws a descriptive error if LLM returns non-JSON or malformed JSON"
    - "generateQuestion() throws a descriptive error if the question fails difficulty heuristic matching"
    - "generateQuestion() retries up to 3 times with exponential backoff before propagating the error"
    - "QuizContext provides session state (config, current question index, questions, skipped set)"
    - "QuizContext.initializeSession() sets up session state from a quiz_sessions row"
    - "QuizContext.skipQuestion() adds question index to skippedQuestions set"
    - "QuizContext.getProgress() returns {current, total, percent} correctly at any index"
    - "useQuestionGeneration hook wraps generateQuestion() and exposes loading/error/question state"
    - "Generated questions are persisted to quiz_questions table in Supabase after validation"
  artifacts:
    - path: "src/lib/quiz/questions.ts"
      provides: "generateQuestion() with LLM call, JSON parse, Zod validation, difficulty check, retry logic, and Supabase persist"
      exports: ["generateQuestion", "checkDifficultyMatch", "validateQuestion"]
    - path: "src/context/QuizContext.tsx"
      provides: "QuizProvider and useQuizSession hook for session state across quiz pages"
      exports: ["QuizProvider", "useQuizSession", "QuizSessionState"]
    - path: "src/hooks/useQuestionGeneration.ts"
      provides: "React hook wrapping generateQuestion() with loading/error/data state"
      exports: ["useQuestionGeneration"]
  key_links:
    - from: "src/lib/quiz/questions.ts"
      to: "src/lib/llm/index.ts"
      via: "getLLMProvider() called inside generateQuestion() to get the configured provider"
      pattern: "getLLMProvider"
    - from: "src/lib/quiz/questions.ts"
      to: "src/types/quiz.ts"
      via: "GeneratedQuestionSchema.parse() validates LLM JSON output"
      pattern: "GeneratedQuestionSchema"
    - from: "src/lib/quiz/questions.ts"
      to: "public.quiz_questions"
      via: "supabase.from('quiz_questions').insert() persists validated question"
      pattern: "quiz_questions.*insert"
    - from: "src/hooks/useQuestionGeneration.ts"
      to: "src/lib/quiz/questions.ts"
      via: "generateQuestion() called inside useCallback, loading/error state managed around it"
      pattern: "generateQuestion"
    - from: "src/context/QuizContext.tsx"
      to: "src/types/quiz.ts"
      via: "QuizSessionState stores GeneratedQuestion[] loaded from session"
      pattern: "GeneratedQuestion"
---

<objective>
Build the question generation service (LLM call + Zod validation + difficulty gate + retry + Supabase persist), the QuizContext for session state management, and the useQuestionGeneration hook. This plan is the LLM integration core — Plan 02-04 consumes all three exports.

Purpose: QUIZ-01 (question display) and QUIZ-06 (topic display) both require questions to exist in state and in the database before they can be rendered. This plan creates the full pipeline from LLM prompt to validated, persisted question ready for display.

Output:
- src/lib/quiz/questions.ts: generateQuestion() with full validation + retry + persist pipeline
- src/context/QuizContext.tsx: QuizProvider and useQuizSession hook
- src/hooks/useQuestionGeneration.ts: React hook wrapping the generation call
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quiz-setup-and-question-generation/02-RESEARCH.md
@.planning/phases/02-quiz-setup-and-question-generation/02-01-SUMMARY.md

Phase 2 dependencies (from 02-01):
- getLLMProvider() from src/lib/llm/index.ts returns ClaudeProvider or OpenAIProvider
- GeneratedQuestionSchema, GeneratedQuestion, Difficulty, QuestionType from src/types/quiz.ts
- QuizSessionRow, QuizQuestionInsert from src/types/database.ts
- supabase client from src/lib/supabase.ts

Quality gate: less than 20% malformed/off-difficulty questions required before shipping (per ROADMAP.md risk mitigation).
Retry pattern: 3 attempts with exponential backoff (1s, 2s, 4s) before propagating error.
Context window safety: generate questions on-demand one at a time (not pre-batched) — per research open question resolution.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build question generation service with validation and retry</name>
  <files>
    src/lib/quiz/questions.ts
  </files>
  <action>
    Create `src/lib/quiz/questions.ts`:

    ```typescript
    // src/lib/quiz/questions.ts
    // Question generation pipeline:
    // 1. Call LLM with versioned prompt
    // 2. Parse JSON response
    // 3. Validate against GeneratedQuestionSchema (Zod)
    // 4. Check difficulty match heuristic
    // 5. Persist to quiz_questions table
    // 6. Return GeneratedQuestion to caller
    //
    // Retries up to 3 times with exponential backoff on any step failure.
    // Throws descriptive errors so callers can surface them to users.
    import { supabase } from '../supabase'
    import { getLLMProvider } from '../llm'
    import { GeneratedQuestionSchema } from '../../types/quiz'
    import type { GeneratedQuestion, Difficulty } from '../../types/quiz'
    import type { QuestionGenerationParams } from '../llm/types'

    // --- Validation helpers ---

    export function validateQuestion(raw: unknown): GeneratedQuestion {
      const result = GeneratedQuestionSchema.safeParse(raw)
      if (!result.success) {
        const issues = result.error.issues.map(i => `${i.path.join('.')}: ${i.message}`).join('; ')
        throw new Error(`Question schema validation failed: ${issues}`)
      }
      return result.data
    }

    /**
     * Heuristic difficulty matching.
     * Checks word count and complexity vocabulary against requested difficulty.
     * Returns false if mismatch detected — caller should retry or discard the question.
     *
     * NOTE: This is intentionally a lightweight heuristic, not an LLM-powered check.
     * It catches obvious mismatches (e.g., a 30-word beginner question marked as advanced)
     * without adding a second LLM call per question.
     */
    export function checkDifficultyMatch(question: GeneratedQuestion, requested: Difficulty): boolean {
      const bodyLength = question.body.length
      const hasAdvancedVocab = /\b(abstract|generics|reflection|metaprogramming|concurren|parallelism|architecture|distributed|scalab|microservice|asynchronous|mutex|semaphore|garbage\s*collect)\b/i.test(question.body)

      switch (requested) {
        case 'beginner':
          // Beginner questions should be concise and avoid advanced vocabulary
          return bodyLength <= 800 && !hasAdvancedVocab
        case 'normal':
          // Normal questions have moderate length
          return bodyLength >= 80 && bodyLength <= 1500
        case 'advanced':
          // Advanced questions should be longer OR cover complex concepts
          return bodyLength >= 300 || hasAdvancedVocab
        default:
          return true
      }
    }

    // --- Core generation function ---

    interface GenerateQuestionOptions {
      params: QuestionGenerationParams
      sessionId: string
      questionIndex: number
    }

    /**
     * Generates, validates, and persists one question.
     * Retries up to maxRetries times on any failure (JSON parse, schema validation, difficulty mismatch).
     * Throws if all retries exhausted.
     */
    export async function generateQuestion(
      options: GenerateQuestionOptions,
      maxRetries = 3
    ): Promise<GeneratedQuestion> {
      const { params, sessionId, questionIndex } = options
      let lastError: Error = new Error('Unknown error')

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          // Step 1: Call LLM
          const llmProvider = getLLMProvider()
          const rawResponse = await llmProvider.generateQuestion(params)

          // Step 2: Parse JSON
          let parsed: unknown
          try {
            // Strip potential markdown code fences the LLM may add despite instructions
            const cleaned = rawResponse
              .replace(/^```(?:json)?\s*/i, '')
              .replace(/\s*```\s*$/, '')
              .trim()
            parsed = JSON.parse(cleaned)
          } catch {
            throw new Error(`LLM returned non-JSON response (attempt ${attempt + 1}): ${rawResponse.substring(0, 200)}`)
          }

          // Step 3: Zod schema validation
          const question = validateQuestion(parsed)

          // Step 4: Difficulty heuristic check
          if (!checkDifficultyMatch(question, params.difficulty)) {
            throw new Error(
              `Difficulty mismatch: requested '${params.difficulty}' but question body length ${question.body.length} chars does not match heuristic`
            )
          }

          // Step 5: Persist to Supabase
          const { error: insertError } = await supabase
            .from('quiz_questions')
            .insert({
              session_id: sessionId,
              question_index: questionIndex,
              title: question.title,
              body: question.body,
              type: question.type,
              difficulty: question.difficulty,
              topic: question.topic,
              expected_format: question.expectedFormat ?? null
            })

          if (insertError) {
            throw new Error(`Failed to persist question to database: ${insertError.message}`)
          }

          // Step 6: Return validated question
          return question

        } catch (err) {
          lastError = err instanceof Error ? err : new Error(String(err))

          // Exponential backoff before retry: 1s, 2s, 4s
          if (attempt < maxRetries - 1) {
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000))
          }
        }
      }

      throw new Error(`Question generation failed after ${maxRetries} attempts. Last error: ${lastError.message}`)
    }
    ```
  </action>
  <verify>
    - Run: `npx tsc --noEmit` — generateQuestion, validateQuestion, checkDifficultyMatch must type-check cleanly
    - Verify checkDifficultyMatch returns false for a 20-char body with difficulty='advanced' by inspecting the logic manually
    - Verify the JSON cleaning step strips ``` fences (test the regex against "```json\n{...}\n```" mentally)
    - Confirm the insert payload matches QuizQuestionInsert type from database.ts
  </verify>
  <done>
    - src/lib/quiz/questions.ts exports: generateQuestion(), validateQuestion(), checkDifficultyMatch()
    - generateQuestion() retries up to 3 times with exponential backoff
    - validateQuestion() uses GeneratedQuestionSchema.safeParse() and throws with field-level error messages
    - checkDifficultyMatch() implements beginner/normal/advanced heuristics
    - Successful generation persists the question to quiz_questions table
    - TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Build QuizContext and useQuestionGeneration hook</name>
  <files>
    src/context/QuizContext.tsx
    src/hooks/useQuestionGeneration.ts
  </files>
  <action>
    **src/context/QuizContext.tsx** — Session state shared across quiz pages:

    ```tsx
    // src/context/QuizContext.tsx
    // Local quiz session state management using React Context.
    // Stores: session config, current question index, generated questions, skipped questions.
    // NOT persisted to localStorage — session is fetched from Supabase on mount (Plan 02-04).
    // TanStack Query handles server state; this Context handles derived UI state only.
    import React, { createContext, useContext, useState } from 'react'
    import type { QuizSessionRow } from '../types/database'
    import type { GeneratedQuestion } from '../types/quiz'

    export interface QuizSessionState {
      sessionId: string
      config: {
        topics: string[]
        difficulty: QuizSessionRow['difficulty']
        questionTypes: string[]
        questionCount: number
      }
      currentQuestionIndex: number
      totalQuestions: number
      questions: GeneratedQuestion[]             // Questions generated so far
      skippedQuestions: Set<number>             // Indices of skipped questions
    }

    interface QuizContextType {
      session: QuizSessionState | null
      // Initialize from a fetched quiz_sessions row
      initializeSession: (sessionRow: QuizSessionRow) => void
      // Add a newly generated question to local state
      addQuestion: (question: GeneratedQuestion) => void
      // Skip current question (adds to skipped set, advances index)
      skipQuestion: () => void
      // Advance to next question (after answer submitted)
      moveToNextQuestion: () => void
      // Progress helpers
      getProgress: () => { current: number; total: number; percent: number }
      isSessionComplete: () => boolean
    }

    const QuizContext = createContext<QuizContextType | undefined>(undefined)

    export function QuizProvider({ children }: { children: React.ReactNode }) {
      const [session, setSession] = useState<QuizSessionState | null>(null)

      const initializeSession = (sessionRow: QuizSessionRow) => {
        setSession({
          sessionId: sessionRow.id,
          config: {
            topics: sessionRow.topics,
            difficulty: sessionRow.difficulty,
            questionTypes: sessionRow.question_types,
            questionCount: sessionRow.question_count
          },
          currentQuestionIndex: 0,
          totalQuestions: sessionRow.question_count,
          questions: [],
          skippedQuestions: new Set()
        })
      }

      const addQuestion = (question: GeneratedQuestion) => {
        setSession(prev => {
          if (!prev) return null
          return { ...prev, questions: [...prev.questions, question] }
        })
      }

      const skipQuestion = () => {
        setSession(prev => {
          if (!prev) return null
          const newSkipped = new Set(prev.skippedQuestions)
          newSkipped.add(prev.currentQuestionIndex)
          return {
            ...prev,
            skippedQuestions: newSkipped,
            currentQuestionIndex: prev.currentQuestionIndex + 1
          }
        })
      }

      const moveToNextQuestion = () => {
        setSession(prev => {
          if (!prev) return null
          return { ...prev, currentQuestionIndex: prev.currentQuestionIndex + 1 }
        })
      }

      const getProgress = () => {
        if (!session) return { current: 0, total: 0, percent: 0 }
        const current = session.currentQuestionIndex + 1
        const total = session.totalQuestions
        return {
          current: Math.min(current, total),
          total,
          percent: Math.round((Math.min(current, total) / total) * 100)
        }
      }

      const isSessionComplete = () => {
        if (!session) return false
        return session.currentQuestionIndex >= session.totalQuestions
      }

      return (
        <QuizContext.Provider value={{
          session,
          initializeSession,
          addQuestion,
          skipQuestion,
          moveToNextQuestion,
          getProgress,
          isSessionComplete
        }}>
          {children}
        </QuizContext.Provider>
      )
    }

    export function useQuizSession(): QuizContextType {
      const context = useContext(QuizContext)
      if (!context) {
        throw new Error('useQuizSession must be used within a QuizProvider')
      }
      return context
    }
    ```

    **src/hooks/useQuestionGeneration.ts** — React hook wrapping the generation pipeline:

    ```typescript
    // src/hooks/useQuestionGeneration.ts
    // React hook for generating questions on demand.
    // Wraps generateQuestion() with loading/error/data state management.
    // Called by QuizSessionPage (Plan 02-04) when advancing to each question.
    import { useState, useCallback } from 'react'
    import { generateQuestion } from '../lib/quiz/questions'
    import type { GeneratedQuestion } from '../types/quiz'
    import type { QuestionGenerationParams } from '../lib/llm/types'

    interface UseQuestionGenerationOptions {
      sessionId: string
    }

    interface UseQuestionGenerationReturn {
      question: GeneratedQuestion | null
      isLoading: boolean
      error: string | null
      generate: (params: QuestionGenerationParams, questionIndex: number) => Promise<GeneratedQuestion | null>
      reset: () => void
    }

    export function useQuestionGeneration(
      { sessionId }: UseQuestionGenerationOptions
    ): UseQuestionGenerationReturn {
      const [question, setQuestion] = useState<GeneratedQuestion | null>(null)
      const [isLoading, setIsLoading] = useState(false)
      const [error, setError] = useState<string | null>(null)

      const generate = useCallback(async (
        params: QuestionGenerationParams,
        questionIndex: number
      ): Promise<GeneratedQuestion | null> => {
        setIsLoading(true)
        setError(null)
        setQuestion(null)

        try {
          const generated = await generateQuestion(
            { params, sessionId, questionIndex },
            3 // maxRetries
          )
          setQuestion(generated)
          return generated
        } catch (err) {
          const message = err instanceof Error
            ? err.message
            : 'Failed to generate question. Please try again.'
          setError(message)
          return null
        } finally {
          setIsLoading(false)
        }
      }, [sessionId])

      const reset = useCallback(() => {
        setQuestion(null)
        setError(null)
        setIsLoading(false)
      }, [])

      return { question, isLoading, error, generate, reset }
    }
    ```

    **Wire QuizProvider into App.tsx** — Wrap the quiz routes with QuizProvider:

    In src/App.tsx, import QuizProvider and wrap only the quiz session route (not the whole app — QuizProvider state is session-scoped):
    ```tsx
    import { QuizProvider } from './context/QuizContext'
    // Wrap the /quiz/:sessionId route:
    <Route
      path="/quiz/:sessionId"
      element={
        <ProtectedRoute>
          <QuizProvider>
            {/* QuizSessionPage added in Plan 02-04 */}
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
              <p className="text-gray-500">Loading quiz session...</p>
            </div>
          </QuizProvider>
        </ProtectedRoute>
      }
    />
    ```
  </action>
  <verify>
    - Run: `npx tsc --noEmit` — all three files must compile cleanly
    - Run: `npm run build` — must succeed with no errors
    - Inspect QuizContext: verify skipQuestion() adds to skippedQuestions AND increments currentQuestionIndex in one setState call (no race condition with two separate setStates)
    - Inspect getProgress(): verify it returns {current: 1, total: 5, percent: 20} when currentQuestionIndex=0 and totalQuestions=5
    - Inspect useQuestionGeneration: verify generate() sets isLoading=true before the async call and isLoading=false in the finally block
  </verify>
  <done>
    - src/context/QuizContext.tsx exports: QuizProvider, useQuizSession, QuizSessionState
    - QuizProvider state: session, initializeSession, addQuestion, skipQuestion, moveToNextQuestion, getProgress, isSessionComplete
    - skipQuestion() atomically increments currentQuestionIndex and adds to skippedQuestions in single setState
    - src/hooks/useQuestionGeneration.ts exports: useQuestionGeneration hook with question/isLoading/error/generate/reset
    - QuizProvider wraps /quiz/:sessionId route in App.tsx
    - TypeScript compiles cleanly; npm run build succeeds
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `npm run build` — must succeed
2. `npx tsc --noEmit` — zero TypeScript errors across all new files
3. Manually verify question generation pipeline logic:
   - Open src/lib/quiz/questions.ts and confirm the JSON cleaning regex handles ``` code fences
   - Confirm retry loop uses exponential backoff: attempt 0 → no wait, attempt 1 → 1s, attempt 2 → 2s
   - Confirm the Supabase insert inside the loop runs ONLY after both validateQuestion and checkDifficultyMatch succeed
4. Manually verify QuizContext:
   - skipQuestion() must update both currentQuestionIndex and skippedQuestions in a single setSession call
   - isSessionComplete() must return true when currentQuestionIndex >= totalQuestions (not strictly equal, to handle edge cases)
</verification>

<success_criteria>
- generateQuestion() validates LLM output through Zod schema + difficulty heuristic + persists to Supabase
- generateQuestion() retries up to 3 times, throwing descriptive error if all attempts fail
- QuizContext provides session state with skip, advance, and progress tracking
- useQuestionGeneration hook exposes loading/error/data state for UI consumption
- npm run build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-quiz-setup-and-question-generation/02-03-SUMMARY.md` documenting:
- Whether a live API call test was performed and the result
- checkDifficultyMatch() heuristic accuracy observations (if testable)
- Any issues with dangerouslyAllowBrowser on the Anthropic/OpenAI SDK
- QuizContext design decisions (why session-scoped, not app-scoped)
- Any deviations from this plan
</output>
