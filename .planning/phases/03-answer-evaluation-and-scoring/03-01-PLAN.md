---
phase: 03-answer-evaluation-and-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260219000000_quiz_answers.sql
  - src/types/database.ts
  - src/lib/quiz/answers.ts
autonomous: true
requirements: [DATA-01, DATA-03, EVAL-05]

must_haves:
  truths:
    - "A quiz_answers row is written to the database the moment a user submits an answer, before LLM evaluation begins"
    - "If evaluation fails mid-way, the answer row survives in DB with status='pending_evaluation' (no orphaned answers)"
    - "The insertAnswer() function returns an answer ID that subsequent evaluation updates can target"
    - "The updateAnswerEvaluation() function atomically writes score, feedback, model_answer, and status='completed' to the same row"
    - "TypeScript types for quiz_answers table are exported from database.ts with full Row/Insert/Update shapes"
  artifacts:
    - path: "supabase/migrations/20260219000000_quiz_answers.sql"
      provides: "quiz_answers table with RLS, indexes, and auto-updated_at trigger"
      contains: "CREATE TABLE.*quiz_answers"
    - path: "src/types/database.ts"
      provides: "QuizAnswerRow, QuizAnswerInsert, QuizAnswerUpdate type aliases"
      exports: ["QuizAnswerRow", "QuizAnswerInsert", "QuizAnswerUpdate"]
    - path: "src/lib/quiz/answers.ts"
      provides: "insertAnswer() and updateAnswerEvaluation() service functions"
      exports: ["insertAnswer", "updateAnswerEvaluation"]
  key_links:
    - from: "src/lib/quiz/answers.ts"
      to: "supabase quiz_answers table"
      via: "supabase.from('quiz_answers').insert()"
      pattern: "from\\('quiz_answers'\\)"
    - from: "src/types/database.ts"
      to: "quiz_answers table schema"
      via: "QuizAnswerRow interface"
      pattern: "quiz_answers"
---

<objective>
Create the quiz_answers database table and the atomic persistence service that saves answers and evaluation results to the database.

Purpose: Every answer submission must be saved to the database BEFORE LLM evaluation begins. If evaluation fails, the answer survives with status='pending_evaluation' so it is never lost. This is the DATA-01/DATA-03/EVAL-05 foundation — everything else in Phase 3 writes through this layer.

Output: Migration file, TypeScript types, and two service functions (insertAnswer, updateAnswerEvaluation).
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-answer-evaluation-and-scoring/03-RESEARCH.md

<!-- Phase 2 DB pattern reference -->
@src/types/database.ts
@supabase/migrations/20260218232536_quiz_schema.sql
@src/lib/quiz/sessions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quiz_answers migration and TypeScript types</name>
  <files>
    supabase/migrations/20260219000000_quiz_answers.sql
    src/types/database.ts
  </files>
  <action>
    Create the migration at supabase/migrations/20260219000000_quiz_answers.sql:

    ```sql
    -- Migration: quiz_answers
    -- Stores user answers and LLM evaluation results.
    -- Atomic pattern: insert with status='pending_evaluation' first, then update with score/feedback.
    -- If evaluation fails, row stays 'pending_evaluation' — visible in Phase 4 history as incomplete.

    CREATE TABLE IF NOT EXISTS public.quiz_answers (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      session_id UUID NOT NULL REFERENCES public.quiz_sessions(id) ON DELETE CASCADE,
      question_id UUID REFERENCES public.quiz_questions(id) ON DELETE SET NULL,
      question_index INT NOT NULL,        -- denormalized for fast Phase 4 history queries
      user_answer TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'pending_evaluation'
        CHECK (status IN ('pending_evaluation', 'completed', 'skipped', 'evaluation_failed')),
      score INT CHECK (score >= 0 AND score <= 100),
      reasoning TEXT,                     -- G-Eval chain-of-thought (for debugging)
      feedback TEXT,
      model_answer TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE (session_id, question_index) -- one answer per question per session
    );

    -- RLS: Users can only access answers in their own sessions
    ALTER TABLE public.quiz_answers ENABLE ROW LEVEL SECURITY;

    CREATE POLICY "quiz_answers_select_own"
      ON public.quiz_answers FOR SELECT
      TO authenticated
      USING (EXISTS (
        SELECT 1 FROM public.quiz_sessions
        WHERE id = session_id
        AND user_id = (SELECT auth.uid())
      ));

    CREATE POLICY "quiz_answers_insert_own"
      ON public.quiz_answers FOR INSERT
      TO authenticated
      WITH CHECK (EXISTS (
        SELECT 1 FROM public.quiz_sessions
        WHERE id = session_id
        AND user_id = (SELECT auth.uid())
      ));

    CREATE POLICY "quiz_answers_update_own"
      ON public.quiz_answers FOR UPDATE
      TO authenticated
      USING (EXISTS (
        SELECT 1 FROM public.quiz_sessions
        WHERE id = session_id
        AND user_id = (SELECT auth.uid())
      ))
      WITH CHECK (EXISTS (
        SELECT 1 FROM public.quiz_sessions
        WHERE id = session_id
        AND user_id = (SELECT auth.uid())
      ));

    -- Indexes for Phase 4 dashboard queries
    CREATE INDEX IF NOT EXISTS idx_quiz_answers_session_id ON public.quiz_answers(session_id);
    CREATE INDEX IF NOT EXISTS idx_quiz_answers_status ON public.quiz_answers(status);

    -- Auto-update updated_at on changes
    CREATE OR REPLACE FUNCTION public.handle_quiz_answer_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS on_quiz_answer_updated ON public.quiz_answers;
    CREATE TRIGGER on_quiz_answer_updated
      BEFORE UPDATE ON public.quiz_answers
      FOR EACH ROW EXECUTE FUNCTION public.handle_quiz_answer_updated_at();
    ```

    Then apply the migration: `npx supabase db push` (or `supabase db push` if CLI is on PATH). Confirm it applies without error.

    Then update src/types/database.ts — add quiz_answers to the Tables map (after quiz_questions, before topics):

    ```typescript
    quiz_answers: {
      Row: {
        id: string
        session_id: string
        question_id: string | null
        question_index: number
        user_answer: string
        status: 'pending_evaluation' | 'completed' | 'skipped' | 'evaluation_failed'
        score: number | null
        reasoning: string | null
        feedback: string | null
        model_answer: string | null
        created_at: string
        updated_at: string
      }
      Insert: {
        id?: string
        session_id: string
        question_id?: string | null
        question_index: number
        user_answer: string
        status?: 'pending_evaluation' | 'completed' | 'skipped' | 'evaluation_failed'
        score?: number | null
        reasoning?: string | null
        feedback?: string | null
        model_answer?: string | null
        created_at?: string
        updated_at?: string
      }
      Update: {
        status?: 'pending_evaluation' | 'completed' | 'skipped' | 'evaluation_failed'
        score?: number | null
        reasoning?: string | null
        feedback?: string | null
        model_answer?: string | null
        updated_at?: string
      }
      Relationships: []
    }
    ```

    Also add type aliases at the bottom of database.ts:
    ```typescript
    export type QuizAnswerRow = Database['public']['Tables']['quiz_answers']['Row']
    export type QuizAnswerInsert = Database['public']['Tables']['quiz_answers']['Insert']
    export type QuizAnswerUpdate = Database['public']['Tables']['quiz_answers']['Update']
    ```

    Apply migration with: `npx supabase db push`
    If that fails because Supabase CLI is not installed locally, note in the task output that the migration needs to be applied via the Supabase dashboard SQL editor by copy-pasting the migration file contents.
  </action>
  <verify>
    Run: `npx tsc --noEmit` — zero TypeScript errors.
    Check: `src/types/database.ts` contains `quiz_answers` table definition with all fields.
    Check: Type aliases `QuizAnswerRow`, `QuizAnswerInsert`, `QuizAnswerUpdate` are exported.
  </verify>
  <done>
    quiz_answers table is defined in migration SQL with RLS policies mirroring quiz_questions pattern. TypeScript types are exported with correct status union type. `npx tsc --noEmit` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create atomic answer persistence service</name>
  <files>src/lib/quiz/answers.ts</files>
  <action>
    Create src/lib/quiz/answers.ts with two service functions. Follow the existing pattern in src/lib/quiz/sessions.ts (import supabase, typed return, throw on error).

    ```typescript
    // src/lib/quiz/answers.ts
    // Atomic answer persistence service.
    // Pattern: insert answer with status='pending_evaluation' (DATA-01),
    // then evaluate, then updateAnswerEvaluation() with score/feedback.
    // If evaluation fails, the pending_evaluation row survives — no orphaned data (DATA-03).
    import { supabase } from '../supabase'
    import type { QuizAnswerRow } from '../../types/database'

    export interface InsertAnswerParams {
      sessionId: string
      questionId: string | null   // null if question not yet saved to quiz_questions
      questionIndex: number
      userAnswer: string
    }

    export interface EvaluationUpdateParams {
      score: number
      reasoning: string
      feedback: string
      modelAnswer: string
    }

    // Step 1 of atomic pattern: save answer before evaluation begins.
    // Returns the full row including generated id, used by updateAnswerEvaluation.
    export async function insertAnswer(params: InsertAnswerParams): Promise<QuizAnswerRow> {
      const { data, error } = await supabase
        .from('quiz_answers')
        .insert({
          session_id: params.sessionId,
          question_id: params.questionId,
          question_index: params.questionIndex,
          user_answer: params.userAnswer,
          status: 'pending_evaluation' as const
        })
        .select()
        .single()

      if (error) throw new Error(`Failed to save answer: ${error.message}`)
      if (!data) throw new Error('No data returned from answer insert')

      return data as QuizAnswerRow
    }

    // Step 2 of atomic pattern: update with LLM evaluation result.
    // Called only when evaluation succeeds. Sets status='completed'.
    export async function updateAnswerEvaluation(
      answerId: string,
      evaluation: EvaluationUpdateParams
    ): Promise<void> {
      const { error } = await supabase
        .from('quiz_answers')
        .update({
          score: evaluation.score,
          reasoning: evaluation.reasoning,
          feedback: evaluation.feedback,
          model_answer: evaluation.modelAnswer,
          status: 'completed' as const
        })
        .eq('id', answerId)

      if (error) throw new Error(`Failed to save evaluation: ${error.message}`)
    }

    // Mark an answer as evaluation_failed (called when all retries exhausted).
    export async function markAnswerEvaluationFailed(answerId: string): Promise<void> {
      const { error } = await supabase
        .from('quiz_answers')
        .update({ status: 'evaluation_failed' as const })
        .eq('id', answerId)

      if (error) throw new Error(`Failed to mark answer evaluation failed: ${error.message}`)
    }

    // Mark session completion in quiz_sessions table (COMP-01).
    export async function completeQuizSession(sessionId: string): Promise<void> {
      const { error } = await supabase
        .from('quiz_sessions')
        .update({ status: 'completed' as const })
        .eq('id', sessionId)

      if (error) throw new Error(`Failed to complete quiz session: ${error.message}`)
    }
    ```

    Note: `completeQuizSession` is included here because it operates on the same data layer (quiz_sessions) and is needed by Plan 03-04 without requiring a separate service file.
  </action>
  <verify>
    Run: `npx tsc --noEmit` — zero TypeScript errors.
    Check: `src/lib/quiz/answers.ts` exports `insertAnswer`, `updateAnswerEvaluation`, `markAnswerEvaluationFailed`, `completeQuizSession`.
    Check: `InsertAnswerParams` and `EvaluationUpdateParams` interfaces are exported (needed by Plan 03-02/03-03).
  </verify>
  <done>
    Four functions exported: insertAnswer returns QuizAnswerRow, updateAnswerEvaluation and markAnswerEvaluationFailed accept answerId string, completeQuizSession accepts sessionId. All typed, all throw on Supabase error. `npx tsc --noEmit` passes cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors after both tasks complete.
2. `src/types/database.ts` contains `quiz_answers` table with correct status union: 'pending_evaluation' | 'completed' | 'skipped' | 'evaluation_failed'.
3. `src/lib/quiz/answers.ts` exports all four functions with correct signatures.
4. Migration file exists at `supabase/migrations/20260219000000_quiz_answers.sql` with RLS policies and indexes.
5. `npx supabase db push` or manual SQL execution applies migration without error.
</verification>

<success_criteria>
- quiz_answers table created in Supabase with RLS enabled (users can only see own answers)
- TypeScript types QuizAnswerRow/Insert/Update exported from database.ts
- insertAnswer() saves a row with status='pending_evaluation' and returns the row ID
- updateAnswerEvaluation() updates the row with score, feedback, model_answer, status='completed'
- completeQuizSession() marks quiz_sessions status='completed'
- All four functions throw descriptive errors on failure
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-answer-evaluation-and-scoring/03-01-SUMMARY.md` following the template at `/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md`.
</output>
