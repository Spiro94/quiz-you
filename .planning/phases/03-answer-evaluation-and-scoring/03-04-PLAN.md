---
phase: 03-answer-evaluation-and-scoring
plan: 04
type: execute
wave: 4
depends_on: [03-01, 03-03]
files_modified:
  - src/pages/QuizSession.tsx
  - src/context/QuizContext.tsx
autonomous: false
requirements: [COMP-01, DATA-01, DATA-03]

must_haves:
  truths:
    - "When the last question is answered or skipped, the quiz_sessions row status is updated to 'completed' in the database"
    - "The session completion triggers navigation away from the quiz session page"
    - "Skipped questions are recorded in the database as quiz_answers rows with status='skipped' so session history is complete"
    - "The QuizSession page handles the complete end-to-end flow: fetch → generate → answer/skip → complete — no dead ends or stuck states"
    - "A human verifier can start a quiz, answer all questions, and see evaluation for each, confirming the full loop works"
  artifacts:
    - path: "src/pages/QuizSession.tsx"
      provides: "isSessionComplete triggers completeQuizSession() then navigate('/dashboard'); handleSkip saves skipped answer to DB"
      contains: "completeQuizSession"
    - path: "src/context/QuizContext.tsx"
      provides: "No changes needed if isSessionComplete() logic is correct — verify and update if required"
  key_links:
    - from: "src/pages/QuizSession.tsx"
      to: "src/lib/quiz/answers.ts completeQuizSession()"
      via: "called inside useEffect when isSessionComplete() returns true"
      pattern: "completeQuizSession"
    - from: "src/pages/QuizSession.tsx"
      to: "src/lib/quiz/answers.ts insertAnswer()"
      via: "handleSkip calls insertAnswer with status='skipped' then skipQuestion()"
      pattern: "handleSkip.*insertAnswer|insertAnswer.*skip"
---

<objective>
Complete the session lifecycle: when all questions are answered or skipped, mark the session 'completed' in the database and navigate away. Also ensure skipped questions produce a quiz_answers row (status='skipped') so session history has no gaps.

Purpose: COMP-01 requires the session to end automatically. DATA-03 requires complete session history — if a skip creates no DB record, the session history will show gaps. This plan closes both requirements and includes a human-verify checkpoint confirming the full Phase 3 loop works end-to-end.

Output: QuizSession.tsx updated for session completion + skip persistence. Human verification of the complete evaluation flow.
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-answer-evaluation-and-scoring/03-RESEARCH.md
@.planning/phases/03-answer-evaluation-and-scoring/03-01-SUMMARY.md
@.planning/phases/03-answer-evaluation-and-scoring/03-03-SUMMARY.md

<!-- Files being modified -->
@src/pages/QuizSession.tsx
@src/context/QuizContext.tsx
@src/lib/quiz/answers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist skipped answers and complete session on last question</name>
  <files>src/pages/QuizSession.tsx</files>
  <action>
    Update src/pages/QuizSession.tsx with two changes:

    **Change 1 — handleSkip persists a 'skipped' answer row:**

    The current handleSkip only calls skipQuestion() (QuizContext). For DATA-03 compliance, skipped questions must also produce a quiz_answers DB row so session history is complete.

    Replace the current handleSkip:
    ```typescript
    const handleSkip = () => {
      skipQuestion()
    }
    ```

    With:
    ```typescript
    const handleSkip = async () => {
      // Persist skipped answer to DB (DATA-03 — no gaps in session history)
      if (session) {
        const currentQ = session.questions[session.currentQuestionIndex]
        await insertAnswer({
          sessionId: session.sessionId,
          questionId: null,
          questionIndex: session.currentQuestionIndex,
          userAnswer: ''  // empty string = skipped
        }).then(row =>
          // Mark as skipped immediately (no evaluation needed)
          updateAnswerEvaluation(row.id, {
            score: 0,
            reasoning: 'Question was skipped by user.',
            feedback: 'This question was skipped.',
            modelAnswer: currentQ
              ? `${currentQ.title}\n\n${currentQ.body}`
              : 'Question not available.'
          })
        ).catch(() => {
          // Best-effort: DB write failure should not block UI progress
        })
      }
      skipQuestion()
    }
    ```

    Wait — this is slightly off. The status should be 'skipped', not 'completed'. The updateAnswerEvaluation function sets status='completed'. Instead, use a direct supabase update or add an insertSkippedAnswer() function to answers.ts that inserts with status='skipped' and score=0 in one step.

    The cleaner approach: add a small helper at the top of QuizSession.tsx that inserts a skipped answer with status='skipped' and score=0 directly, since the answers.ts service already exports what we need. Check if answers.ts already has a `insertSkippedAnswer` function — if not, do the insert inline using the supabase client imported directly in QuizSession, or import supabase and do a single insert:

    Best approach: add `insertSkippedAnswer(params)` to src/lib/quiz/answers.ts (the file already touched in Plan 03-01):

    ```typescript
    // In src/lib/quiz/answers.ts — add this function:
    export async function insertSkippedAnswer(params: {
      sessionId: string
      questionIndex: number
      questionTitle?: string
    }): Promise<void> {
      const { error } = await supabase
        .from('quiz_answers')
        .insert({
          session_id: params.sessionId,
          question_id: null,
          question_index: params.questionIndex,
          user_answer: '',
          status: 'skipped' as const,
          score: 0,
          reasoning: 'Question skipped by user.',
          feedback: 'This question was skipped.',
          model_answer: params.questionTitle ?? null
        })

      if (error && error.code !== '23505') {
        // 23505 = unique_violation: already skipped (double-click protection)
        throw new Error(`Failed to save skipped answer: ${error.message}`)
      }
    }
    ```

    Then in QuizSession.tsx handleSkip, import and call insertSkippedAnswer (best-effort, don't block):
    ```typescript
    const handleSkip = () => {
      if (session) {
        const currentQ = session.questions[session.currentQuestionIndex]
        insertSkippedAnswer({
          sessionId: session.sessionId,
          questionIndex: session.currentQuestionIndex,
          questionTitle: currentQ?.title
        }).catch(() => {
          // Best-effort — don't block quiz progress if DB write fails
        })
      }
      skipQuestion()
    }
    ```

    **Change 2 — Session completion triggers completeQuizSession() then navigate:**

    The current isSessionComplete useEffect navigates directly to /dashboard. Update it to also call completeQuizSession() first:

    Find the useEffect that checks isSessionComplete():
    ```typescript
    if (isSessionComplete()) {
      navigate('/dashboard') // Session complete — Phase 3 will add a summary screen
      return
    }
    ```

    Replace with:
    ```typescript
    if (isSessionComplete()) {
      // Mark session completed in DB (COMP-01, DATA-01)
      completeQuizSession(session.sessionId).catch(() => {
        // Best-effort — navigate even if DB update fails
      })
      navigate('/dashboard')
      return
    }
    ```

    Import completeQuizSession and insertSkippedAnswer from '../lib/quiz/answers'.

    Also verify: the AnswerInput.tsx onSubmit prop type — if it's `(answer: string) => void`, but QuizSession now has `async (answer: string) => Promise<void>`, TypeScript will complain. Check AnswerInput.tsx prop type and update it to `(answer: string) => void | Promise<void>` if needed. Since AnswerInput just calls the callback and doesn't await it, the type relaxation is safe.

    Also add `src/lib/quiz/answers.ts` to files_modified for the insertSkippedAnswer addition — note: this is a minor addition to Plan 03-01's file, not a new file.
  </action>
  <verify>
    Run: `npx tsc --noEmit` — zero TypeScript errors.
    Run: `npm run build` — builds without errors.
    Check: handleSkip calls `insertSkippedAnswer()` (best-effort, non-blocking).
    Check: isSessionComplete useEffect calls `completeQuizSession(session.sessionId)` before navigate.
    Check: `insertSkippedAnswer` exported from `src/lib/quiz/answers.ts`.
  </verify>
  <done>
    handleSkip persists a quiz_answers row with status='skipped' and score=0 (best-effort, non-blocking). isSessionComplete triggers completeQuizSession() before navigating to dashboard. `npm run build` and `npx tsc --noEmit` both pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verification — full Phase 3 evaluation loop</name>
  <action>Verify the complete Phase 3 flow end-to-end in the browser as described in how-to-verify below.</action>
  <verify>All steps in how-to-verify pass. Supabase tables show correct records.</verify>
  <done>Human approves by typing "approved". All 9 Phase 3 requirements confirmed in live browser.</done>
  <what-built>
    Complete Phase 3 evaluation loop:
    - quiz_answers table in Supabase (Plan 03-01)
    - G-Eval evaluation service with retry and timeout (Plan 03-02)
    - useAnswerEvaluation hook + EvaluationResult component (Plan 03-03)
    - Session completion + skip persistence (Plan 03-04 Task 1)
  </what-built>
  <how-to-verify>
    1. Start the dev server: `npm run dev`
    2. Log in and start a new quiz (select 1 topic, beginner difficulty, 5 questions)
    3. When the first question appears, type a short answer in the textarea (or write code in Monaco)
    4. Click "Submit Answer"
    5. Verify: a spinner appears with "Evaluating your answer..." text
    6. Wait for evaluation (up to 30 seconds)
    7. Verify: EvaluationResult renders with:
       - A numeric score (0-100) in large bold text with color coding
       - A "Feedback" section with specific comments on the answer
       - A "Model Answer" section with a reference answer
       - A "Next Question" button
    8. Click "Next Question" — verify the next question appears and EvaluationResult disappears
    9. Skip a question — verify progress advances and the quiz continues
    10. On the last question, answer it and click "Next Question" — verify navigation to /dashboard
    11. In Supabase Dashboard → Table Editor → quiz_answers: verify rows exist with status='completed' for submitted answers and status='skipped' for skipped questions
    12. In Supabase Dashboard → quiz_sessions: verify the session row has status='completed'

    If evaluation fails (API key issue), verify: error message shown with a "Retry" button; clicking Retry re-submits the same answer.

    Expected: All 9 Phase 3 requirements verified (QUIZ-04, EVAL-01–05, COMP-01, DATA-01, DATA-03).
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe which checks failed and what you observed</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors.
2. `npm run build` — succeeds.
3. Supabase `quiz_answers` table has rows after submitting answers in a test session.
4. Submitted answers: status='completed', score is 0-100 integer, feedback and model_answer are non-null.
5. Skipped questions: status='skipped', score=0, user_answer=''.
6. Session row in `quiz_sessions`: status='completed' after finishing the session.
7. EvaluationResult displays score, feedback, model answer in the UI.
8. Human verification checkpoint approved.
</verification>

<success_criteria>
- All 9 Phase 3 requirement IDs verified end-to-end in the browser:
  - QUIZ-04: Next question button advances the session after evaluation
  - EVAL-01: Score (0-100) displayed after submission
  - EVAL-02: Detailed feedback displayed in markdown
  - EVAL-03: Model answer displayed in markdown
  - EVAL-04: Evaluation completes within 30 seconds
  - EVAL-05: Evaluation saved to quiz_answers table
  - COMP-01: Session marked 'completed' in DB after all questions done
  - DATA-01: All answers saved to quiz_answers before evaluation
  - DATA-03: Skipped questions produce quiz_answers rows with status='skipped'
- Human verification checkpoint approved
- Build passes, zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-answer-evaluation-and-scoring/03-04-SUMMARY.md` following the template at `/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md`.
</output>
