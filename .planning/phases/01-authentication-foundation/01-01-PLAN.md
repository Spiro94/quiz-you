---
phase: 01-authentication-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .env.local
  - .env.example
  - supabase/migrations/001_users_table.sql
  - src/types/database.ts
autonomous: false
# autonomous: false because Task 1 is a checkpoint:human-action (Supabase project creation cannot be automated)
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - DATA-02

user_setup:
  - service: supabase
    why: "Supabase project must exist to obtain URL and anon key for the client, and to run migrations against the database"
    env_vars:
      - name: VITE_SUPABASE_URL
        source: "Supabase Dashboard → Project Settings → API → Project URL"
      - name: VITE_SUPABASE_ANON_KEY
        source: "Supabase Dashboard → Project Settings → API → Project API Keys → anon/public"
    dashboard_config:
      - task: "Create a new Supabase project"
        location: "https://supabase.com/dashboard → New Project"
      - task: "Disable email confirmation for local development (re-enable before production)"
        location: "Supabase Dashboard → Authentication → Providers → Email → Confirm email → OFF"

must_haves:
  truths:
    - "A Supabase project exists and its URL + anon key are stored in .env.local"
    - "A public.users table exists with id, email, display_name, created_at, and updated_at columns"
    - "RLS is enabled on public.users with SELECT, INSERT, and UPDATE policies restricting access to auth.uid() = id"
    - "An index exists on public.users(id) so RLS policy lookups do not cause full table scans"
    - "TypeScript Database types file exists describing the public.users table shape"
  artifacts:
    - path: ".env.local"
      provides: "Supabase project credentials available to Vite via import.meta.env"
    - path: ".env.example"
      provides: "Safe template committed to git documenting required env vars without secrets"
    - path: "supabase/migrations/001_users_table.sql"
      provides: "Repeatable SQL migration creating users table, enabling RLS, creating policies, and adding index"
    - path: "src/types/database.ts"
      provides: "TypeScript types for Supabase Database schema (Tables, Rows, Inserts) used by the client"
  key_links:
    - from: "supabase/migrations/001_users_table.sql"
      to: "public.users"
      via: "CREATE TABLE + ALTER TABLE ENABLE ROW LEVEL SECURITY + CREATE POLICY + CREATE INDEX"
      pattern: "ENABLE ROW LEVEL SECURITY"
    - from: "src/types/database.ts"
      to: "supabase/migrations/001_users_table.sql"
      via: "TypeScript interface mirrors SQL table columns"
      pattern: "users.*Row|users.*Insert"
---

<objective>
Set up the Supabase backend foundation for Quiz You: create the environment configuration, write the users table migration with RLS policies, and generate TypeScript database types. This plan produces zero application UI — it is pure infrastructure that every subsequent plan in Phase 1 depends on.

Purpose: AUTH-01 through AUTH-04 and DATA-02 all require a Supabase project with a secured users table. Without valid credentials and RLS policies, the auth client cannot function and user data would be exposed.

Output:
- .env.local with project credentials (gitignored)
- .env.example template committed to git
- supabase/migrations/001_users_table.sql with table + RLS + index
- src/types/database.ts with TypeScript types matching the schema
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-authentication-foundation/01-RESEARCH.md

Stack (locked): React 19, Vite 8, Tailwind CSS, Supabase (auth + database).
Auth: Email/password only. No OAuth.
No @supabase/supabase-js or react-router-dom in package.json yet — install in this plan.
</context>

<tasks>

<task type="checkpoint:human-action">
  <name>Task 1: Create Supabase project and collect credentials</name>
  <action>Human-only step. Claude cannot create a Supabase project via CLI without authentication. The user must create the project in the Supabase dashboard, then provide the credentials so Claude can write .env.local in Task 2.</action>
  <what-built>Nothing yet — this is a human-only action that Claude cannot perform via CLI or API.</what-built>
  <how-to-verify>
    1. Go to https://supabase.com/dashboard and sign in (create account if needed)
    2. Click "New Project", fill in project name (e.g., "quiz-you"), choose a region close to you, set a strong database password, click "Create new project"
    3. Wait for the project to finish provisioning (~1 minute)
    4. Go to Project Settings → API
    5. Copy "Project URL" (looks like https://abcdefgh.supabase.co)
    6. Copy "anon public" key under "Project API Keys"
    7. In Supabase Dashboard → Authentication → Providers → Email: set "Confirm email" to OFF (for local dev — re-enable before production)
    8. You now have: VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY ready to provide
  </how-to-verify>
  <resume-signal>Paste "SUPABASE_READY url=https://xxx.supabase.co key=eyJ..." — Claude will create .env.local from these values</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Install dependencies and create environment files</name>
  <files>
    package.json
    .env.local
    .env.example
    .gitignore
  </files>
  <action>
    1. Install required packages:
       ```bash
       npm install @supabase/supabase-js react-router-dom zod
       ```
       - @supabase/supabase-js: Supabase client with auth + database
       - react-router-dom: client-side routing for protected routes
       - zod: form input validation before sending to Supabase

    2. Create .env.local with credentials from Task 1's resume signal:
       ```
       VITE_SUPABASE_URL=https://[project-id].supabase.co
       VITE_SUPABASE_ANON_KEY=[anon-key]
       ```

    3. Create .env.example (safe to commit, no secrets):
       ```
       # Supabase project credentials
       # Get these from: Supabase Dashboard → Project Settings → API
       VITE_SUPABASE_URL=https://your-project-id.supabase.co
       VITE_SUPABASE_ANON_KEY=your_anon_public_key_here
       ```

    4. Ensure .gitignore includes .env.local (it should already be there for a Vite project, but verify). Add if missing:
       ```
       .env.local
       .env*.local
       ```

    CRITICAL: Never commit .env.local. The .env.example is the only credentials-related file that goes to git.
  </action>
  <verify>
    - Run: `node -e "require('fs').readFileSync('.env.local', 'utf8').split('\n').forEach(l => console.log(l.includes('KEY') ? l.split('=')[0]+'=[REDACTED]' : l))"` — should show both vars present with values
    - Run: `cat .env.example` — should show placeholder values, not real ones
    - Run: `cat .gitignore | grep env` — should show .env.local is ignored
    - Run: `npm ls @supabase/supabase-js react-router-dom zod` — should show installed versions
  </verify>
  <done>
    - @supabase/supabase-js, react-router-dom, and zod are in package.json dependencies
    - .env.local contains VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY with real values
    - .env.example contains placeholder values (committed to git)
    - .gitignore ignores .env.local
  </done>
</task>

<task type="auto">
  <name>Task 3: Create users table migration with RLS and TypeScript types</name>
  <files>
    supabase/migrations/001_users_table.sql
    src/types/database.ts
  </files>
  <action>
    1. Create `supabase/migrations/001_users_table.sql`:

    ```sql
    -- Migration: 001_users_table
    -- Creates the public.users profile table linked to Supabase Auth users.
    -- auth.users is managed by Supabase Auth; this table stores app-level profile data.
    -- RLS is MANDATORY on all tables per project security policy.

    -- Create users profile table
    CREATE TABLE IF NOT EXISTS public.users (
      id          UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      email       TEXT NOT NULL,
      display_name TEXT,
      created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- Enable Row Level Security — REQUIRED. Without this every row is publicly readable.
    ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

    -- Policy: authenticated users can only see their own profile row
    CREATE POLICY "users_select_own"
      ON public.users
      FOR SELECT
      TO authenticated
      USING ((SELECT auth.uid()) = id);

    -- Policy: authenticated users can insert only their own profile row
    -- WITH CHECK ensures user_id matches auth.uid() — prevents spoofing other users
    CREATE POLICY "users_insert_own"
      ON public.users
      FOR INSERT
      TO authenticated
      WITH CHECK ((SELECT auth.uid()) = id);

    -- Policy: authenticated users can update only their own profile row
    CREATE POLICY "users_update_own"
      ON public.users
      FOR UPDATE
      TO authenticated
      USING ((SELECT auth.uid()) = id)
      WITH CHECK ((SELECT auth.uid()) = id);

    -- Index on id for RLS policy lookups — REQUIRED to prevent full table scans.
    -- Without this, every query does O(n) scan: 10k rows = ~50ms, 1M rows = timeout.
    CREATE INDEX IF NOT EXISTS idx_users_id ON public.users(id);

    -- Function: auto-update updated_at on row modification
    CREATE OR REPLACE FUNCTION public.handle_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Trigger: invoke handle_updated_at before any UPDATE on public.users
    DROP TRIGGER IF EXISTS on_users_updated ON public.users;
    CREATE TRIGGER on_users_updated
      BEFORE UPDATE ON public.users
      FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

    -- Function: auto-create profile row in public.users when new auth user signs up
    -- Called by trigger on auth.users INSERT — eliminates need for client-side profile creation
    CREATE OR REPLACE FUNCTION public.handle_new_auth_user()
    RETURNS TRIGGER AS $$
    BEGIN
      INSERT INTO public.users (id, email)
      VALUES (NEW.id, NEW.email)
      ON CONFLICT (id) DO NOTHING;
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Trigger: invoke handle_new_auth_user after new auth.users INSERT
    DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
    CREATE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW EXECUTE FUNCTION public.handle_new_auth_user();
    ```

    2. Run this migration in Supabase Dashboard SQL Editor:
       - Go to Supabase Dashboard → SQL Editor → New query
       - Paste the full SQL above, click Run
       - Verify: no errors, "Success. No rows returned" message

       NOTE: The Supabase Dashboard SQL Editor runs as superuser (bypasses RLS). This is correct for migrations.
       NEVER test your RLS policies from the SQL Editor — it will lie. Test from client SDK (done in 01-02).

    3. Create `src/types/database.ts` with TypeScript types matching the schema:

    ```typescript
    // src/types/database.ts
    // TypeScript types for the Supabase database schema.
    // Mirrors public.users table columns from 001_users_table.sql migration.
    // Used to type the Supabase client: createClient<Database>(url, key)

    export interface Database {
      public: {
        Tables: {
          users: {
            Row: {
              id: string           // UUID, primary key, references auth.users(id)
              email: string        // User's email address
              display_name: string | null  // Optional display name
              created_at: string   // ISO 8601 timestamp
              updated_at: string   // ISO 8601 timestamp, auto-updated
            }
            Insert: {
              id: string
              email: string
              display_name?: string | null
              created_at?: string
              updated_at?: string
            }
            Update: {
              id?: string
              email?: string
              display_name?: string | null
              updated_at?: string
            }
          }
        }
        Views: Record<string, never>
        Functions: Record<string, never>
        Enums: Record<string, never>
      }
    }

    // Convenience type aliases
    export type UserRow = Database['public']['Tables']['users']['Row']
    export type UserInsert = Database['public']['Tables']['users']['Insert']
    export type UserUpdate = Database['public']['Tables']['users']['Update']
    ```
  </action>
  <verify>
    - In Supabase Dashboard → Table Editor: verify `public.users` table appears with id, email, display_name, created_at, updated_at columns
    - In Supabase Dashboard → Authentication → Policies: verify `public.users` has three policies (users_select_own, users_insert_own, users_update_own)
    - In Supabase Dashboard → Database → Indexes: verify `idx_users_id` exists on `public.users`
    - Run TypeScript check: `npx tsc --noEmit` — should pass with no errors on src/types/database.ts
  </verify>
  <done>
    - public.users table exists in Supabase with all 5 columns
    - RLS is enabled and three policies exist (select/insert/update, each using auth.uid() = id)
    - Index idx_users_id exists on public.users(id)
    - Trigger automatically creates profile row in public.users on auth.users INSERT
    - src/types/database.ts exports Database, UserRow, UserInsert, UserUpdate types
    - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify end-to-end:

1. Run `npm run build` — should succeed with no TypeScript errors
2. In Supabase Dashboard → SQL Editor, run:
   ```sql
   SELECT tablename, rowsecurity FROM pg_tables WHERE tablename = 'users' AND schemaname = 'public';
   ```
   Expected: rowsecurity = true
3. In Supabase Dashboard → SQL Editor, run:
   ```sql
   SELECT policyname, cmd FROM pg_policies WHERE tablename = 'users';
   ```
   Expected: 3 rows — users_select_own (SELECT), users_insert_own (INSERT), users_update_own (UPDATE)
4. Check .gitignore prevents .env.local from being staged: `git status` should NOT show .env.local as untracked or modified
</verification>

<success_criteria>
- Supabase project is live with credentials in .env.local
- public.users table has RLS enabled with SELECT, INSERT, UPDATE policies all using auth.uid() = id
- idx_users_id index exists for query performance
- Trigger auto-creates public.users row on every auth signup (no client-side profile creation needed)
- src/types/database.ts provides correct TypeScript types for the schema
- npm run build passes cleanly
- .env.local is gitignored; .env.example is committed
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-foundation/01-01-SUMMARY.md` documenting:
- Supabase project URL (not the key — that stays in .env.local)
- Exact packages installed with versions
- Migration decisions (why trigger-based profile creation vs client-side)
- Any deviations from this plan
</output>
