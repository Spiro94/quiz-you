---
phase: 01-authentication-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/lib/supabase.ts
  - src/context/AuthContext.tsx
  - src/components/auth/SignupForm.tsx
  - src/components/auth/LoginForm.tsx
  - src/components/auth/LogoutButton.tsx
  - src/components/layout/ProtectedRoute.tsx
  - src/pages/Login.tsx
  - src/pages/Signup.tsx
  - src/App.tsx
  - src/main.tsx
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "User can submit the signup form with email and password and is redirected to /dashboard on success"
    - "User can submit the login form with email and password and is redirected to /dashboard on success"
    - "After login, refreshing the browser keeps the user on /dashboard without re-authenticating"
    - "User can click logout from the dashboard and is immediately redirected to /login"
    - "Unauthenticated users visiting /dashboard are redirected to /login"
    - "Auth errors (wrong password, existing email) are displayed inline on the form"
  artifacts:
    - path: "src/lib/supabase.ts"
      provides: "Singleton Supabase client with persistSession:true and autoRefreshToken:true"
      exports: ["supabase"]
    - path: "src/context/AuthContext.tsx"
      provides: "React Context managing user, session, loading state + signUp/signIn/signOut methods"
      exports: ["AuthProvider", "useAuth"]
    - path: "src/components/auth/SignupForm.tsx"
      provides: "Email+password signup form with validation and error display"
      exports: ["SignupForm"]
    - path: "src/components/auth/LoginForm.tsx"
      provides: "Email+password login form with validation and error display"
      exports: ["LoginForm"]
    - path: "src/components/auth/LogoutButton.tsx"
      provides: "Button that calls signOut() and redirects to /login"
      exports: ["LogoutButton"]
    - path: "src/components/layout/ProtectedRoute.tsx"
      provides: "Route wrapper that redirects unauthenticated users to /login"
      exports: ["ProtectedRoute"]
    - path: "src/App.tsx"
      provides: "Router configuration: /login, /signup, /dashboard (protected), / redirect"
  key_links:
    - from: "src/context/AuthContext.tsx"
      to: "src/lib/supabase.ts"
      via: "supabase.auth.getSession() + supabase.auth.onAuthStateChange()"
      pattern: "getSession|onAuthStateChange"
    - from: "src/components/layout/ProtectedRoute.tsx"
      to: "src/context/AuthContext.tsx"
      via: "useAuth() hook checking user and loading"
      pattern: "useAuth"
    - from: "src/components/auth/LogoutButton.tsx"
      to: "src/context/AuthContext.tsx"
      via: "signOut() from useAuth()"
      pattern: "signOut"
    - from: "src/App.tsx"
      to: "src/context/AuthContext.tsx"
      via: "AuthProvider wraps all Routes"
      pattern: "AuthProvider"
---

<objective>
Implement the complete authentication UI layer: Supabase client initialization, AuthContext with session persistence, SignupForm, LoginForm, LogoutButton, ProtectedRoute guard, and router configuration. After this plan, users can create accounts, log in, maintain sessions across browser refreshes, and log out.

Purpose: Addresses AUTH-01 (signup), AUTH-02 (login), AUTH-03 (session persistence), AUTH-04 (logout). This is the user-facing half of the auth system — 01-01 built the backend, this plan builds the frontend.

Output: A working auth flow. `npm run dev` renders login/signup pages. Users can authenticate. The dashboard route is protected. Sessions survive browser refresh.
</objective>

<execution_context>
@/Users/danielvillamizar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielvillamizar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-authentication-foundation/01-RESEARCH.md
@.planning/phases/01-authentication-foundation/01-01-SUMMARY.md

Key decisions from research:
- Use `persistSession: true` + `autoRefreshToken: true` on Supabase client (critical for AUTH-03)
- Session init: `getSession()` first, THEN `onAuthStateChange()` listener — missing getSession() breaks persistence after refresh
- Logout: `await signOut()` BEFORE navigate('/login') — don't redirect before signOut completes
- ProtectedRoute must handle loading state to avoid flash of login page on refresh
- No email confirmation for v1 development (disabled in Supabase per 01-01 setup)
- Logout scope: global (logs out all devices) per research recommendation
- No OAuth, no password reset in Phase 1 — email/password only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Supabase client and AuthContext</name>
  <files>
    src/lib/supabase.ts
    src/context/AuthContext.tsx
  </files>
  <action>
    Create `src/lib/supabase.ts` — singleton Supabase client. This must be imported once and reused everywhere.

    ```typescript
    // src/lib/supabase.ts
    import { createClient } from '@supabase/supabase-js'
    import type { Database } from '../types/database'

    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
    const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error(
        'Missing Supabase environment variables. ' +
        'Ensure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set in .env.local'
      )
    }

    export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
      auth: {
        persistSession: true,       // Store tokens in localStorage so session survives refresh
        autoRefreshToken: true,     // Automatically refresh access token before expiry
        detectSessionInUrl: true,   // Required for magic links (future-proofing, harmless now)
      },
    })
    ```

    Create `src/context/AuthContext.tsx` — central auth state. Key constraints:
    - MUST call `getSession()` on mount before the listener — this restores session from localStorage after page refresh. Without this, the user is logged out on every refresh.
    - MUST set `loading: true` initially and `loading: false` after getSession() resolves — prevents ProtectedRoute from redirecting before session is known.
    - MUST unsubscribe from `onAuthStateChange()` on cleanup — prevents memory leaks.

    ```typescript
    // src/context/AuthContext.tsx
    import React, { createContext, useContext, useEffect, useState } from 'react'
    import type { Session, User } from '@supabase/supabase-js'
    import { supabase } from '../lib/supabase'

    interface AuthContextType {
      user: User | null
      session: Session | null
      loading: boolean
      signUp: (email: string, password: string) => Promise<void>
      signIn: (email: string, password: string) => Promise<void>
      signOut: () => Promise<void>
    }

    const AuthContext = createContext<AuthContextType | undefined>(undefined)

    export function AuthProvider({ children }: { children: React.ReactNode }) {
      const [user, setUser] = useState<User | null>(null)
      const [session, setSession] = useState<Session | null>(null)
      const [loading, setLoading] = useState(true)

      useEffect(() => {
        // Step 1: Restore session from localStorage on app mount.
        // Critical for AUTH-03: without this, browser refresh loses session.
        supabase.auth.getSession().then(({ data: { session } }) => {
          setSession(session)
          setUser(session?.user ?? null)
          setLoading(false)
        })

        // Step 2: Listen for future auth events (login, logout, token refresh).
        // Fires immediately with current session if one exists (handles race conditions).
        const {
          data: { subscription },
        } = supabase.auth.onAuthStateChange((_event, session) => {
          setSession(session)
          setUser(session?.user ?? null)
        })

        return () => subscription.unsubscribe()
      }, [])

      const signUp = async (email: string, password: string): Promise<void> => {
        const { error } = await supabase.auth.signUp({ email, password })
        if (error) throw error
        // public.users profile row is auto-created via trigger (see 01-01 migration)
      }

      const signIn = async (email: string, password: string): Promise<void> => {
        const { error } = await supabase.auth.signInWithPassword({ email, password })
        if (error) throw error
      }

      const signOut = async (): Promise<void> => {
        const { error } = await supabase.auth.signOut({ scope: 'global' })
        if (error) throw error
        // scope: 'global' logs out all devices. onAuthStateChange fires with null session.
        // ProtectedRoute will redirect to /login when user becomes null.
      }

      return (
        <AuthContext.Provider value={{ user, session, loading, signUp, signIn, signOut }}>
          {children}
        </AuthContext.Provider>
      )
    }

    export function useAuth(): AuthContextType {
      const context = useContext(AuthContext)
      if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider')
      }
      return context
    }
    ```
  </action>
  <verify>
    - Run `npx tsc --noEmit` — no TypeScript errors in src/lib/supabase.ts or src/context/AuthContext.tsx
    - Verify src/lib/supabase.ts exports `supabase` (named export, not default)
    - Verify src/context/AuthContext.tsx exports `AuthProvider` and `useAuth`
    - Verify getSession() call appears BEFORE onAuthStateChange() in the useEffect
  </verify>
  <done>
    - src/lib/supabase.ts creates typed Supabase client with persistSession and autoRefreshToken enabled
    - src/context/AuthContext.tsx initializes session from localStorage on mount, then subscribes to future changes
    - loading starts true, becomes false only after getSession() resolves
    - AuthProvider and useAuth are exported correctly
    - TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth form components, ProtectedRoute, and router wiring</name>
  <files>
    src/components/auth/SignupForm.tsx
    src/components/auth/LoginForm.tsx
    src/components/auth/LogoutButton.tsx
    src/components/layout/ProtectedRoute.tsx
    src/pages/Login.tsx
    src/pages/Signup.tsx
    src/App.tsx
    src/main.tsx
  </files>
  <action>
    Create `src/components/auth/SignupForm.tsx`:
    - Controlled form with email and password inputs
    - On submit: calls useAuth().signUp(email, password), redirects to /dashboard on success
    - On error: displays error message inline (never expose raw Supabase error objects to users — extract .message)
    - Password field: type="password", minLength="8" HTML attribute (Supabase enforces minimum length)
    - Disable submit button while loading to prevent double submissions
    - Include link to /login for users who already have an account

    ```typescript
    // src/components/auth/SignupForm.tsx
    import { useState } from 'react'
    import { Link, useNavigate } from 'react-router-dom'
    import { useAuth } from '../../context/AuthContext'

    export function SignupForm() {
      const [email, setEmail] = useState('')
      const [password, setPassword] = useState('')
      const [error, setError] = useState<string | null>(null)
      const [loading, setLoading] = useState(false)
      const { signUp } = useAuth()
      const navigate = useNavigate()

      const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault()
        setLoading(true)
        setError(null)
        try {
          await signUp(email, password)
          navigate('/dashboard')
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Signup failed. Please try again.')
        } finally {
          setLoading(false)
        }
      }

      return (
        <form onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email">Email</label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              autoComplete="email"
            />
          </div>
          <div>
            <label htmlFor="password">Password</label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              minLength={8}
              autoComplete="new-password"
            />
          </div>
          {error && <p role="alert">{error}</p>}
          <button type="submit" disabled={loading}>
            {loading ? 'Creating account...' : 'Create account'}
          </button>
          <p>
            Already have an account? <Link to="/login">Log in</Link>
          </p>
        </form>
      )
    }
    ```

    Create `src/components/auth/LoginForm.tsx` — same pattern as SignupForm but calls signIn():
    - Email + password inputs
    - On success: navigate('/dashboard')
    - On error: display inline error
    - Include link to /signup

    ```typescript
    // src/components/auth/LoginForm.tsx
    import { useState } from 'react'
    import { Link, useNavigate } from 'react-router-dom'
    import { useAuth } from '../../context/AuthContext'

    export function LoginForm() {
      const [email, setEmail] = useState('')
      const [password, setPassword] = useState('')
      const [error, setError] = useState<string | null>(null)
      const [loading, setLoading] = useState(false)
      const { signIn } = useAuth()
      const navigate = useNavigate()

      const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault()
        setLoading(true)
        setError(null)
        try {
          await signIn(email, password)
          navigate('/dashboard')
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Login failed. Check your credentials.')
        } finally {
          setLoading(false)
        }
      }

      return (
        <form onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email">Email</label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              autoComplete="email"
            />
          </div>
          <div>
            <label htmlFor="password">Password</label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              autoComplete="current-password"
            />
          </div>
          {error && <p role="alert">{error}</p>}
          <button type="submit" disabled={loading}>
            {loading ? 'Logging in...' : 'Log in'}
          </button>
          <p>
            Don&apos;t have an account? <Link to="/signup">Sign up</Link>
          </p>
        </form>
      )
    }
    ```

    Create `src/components/auth/LogoutButton.tsx`:
    - Calls signOut() then navigates to /login
    - CRITICAL: await signOut() BEFORE navigate — redirect before signOut completes leaves the user session intact

    ```typescript
    // src/components/auth/LogoutButton.tsx
    import { useState } from 'react'
    import { useNavigate } from 'react-router-dom'
    import { useAuth } from '../../context/AuthContext'

    export function LogoutButton() {
      const { signOut } = useAuth()
      const navigate = useNavigate()
      const [loading, setLoading] = useState(false)

      const handleLogout = async () => {
        setLoading(true)
        try {
          await signOut()   // Wait for session destruction before redirecting
          navigate('/login')
        } catch (err) {
          console.error('Logout failed:', err)
          setLoading(false)
        }
      }

      return (
        <button onClick={handleLogout} disabled={loading}>
          {loading ? 'Logging out...' : 'Log out'}
        </button>
      )
    }
    ```

    Create `src/components/layout/ProtectedRoute.tsx`:
    - Must handle 3 states: loading (show spinner), unauthenticated (redirect to /login), authenticated (render children)
    - loading check MUST come before user check — otherwise on refresh, user=null briefly and causes redirect before session is restored from localStorage

    ```typescript
    // src/components/layout/ProtectedRoute.tsx
    import { Navigate } from 'react-router-dom'
    import { useAuth } from '../../context/AuthContext'

    interface ProtectedRouteProps {
      children: React.ReactNode
    }

    export function ProtectedRoute({ children }: ProtectedRouteProps) {
      const { user, loading } = useAuth()

      // Show loading state while session is being restored from localStorage.
      // Without this, user=null briefly on refresh and ProtectedRoute redirects to /login.
      if (loading) {
        return (
          <div style={{ display: 'flex', justifyContent: 'center', padding: '2rem' }}>
            <span>Loading...</span>
          </div>
        )
      }

      if (!user) {
        return <Navigate to="/login" replace />
      }

      return <>{children}</>
    }
    ```

    Create `src/pages/Login.tsx` and `src/pages/Signup.tsx` as thin page wrappers:

    ```typescript
    // src/pages/Login.tsx
    import { LoginForm } from '../components/auth/LoginForm'

    export default function LoginPage() {
      return (
        <main>
          <h1>Log in to Quiz You</h1>
          <LoginForm />
        </main>
      )
    }

    // src/pages/Signup.tsx
    import { SignupForm } from '../components/auth/SignupForm'

    export default function SignupPage() {
      return (
        <main>
          <h1>Create your Quiz You account</h1>
          <SignupForm />
        </main>
      )
    }
    ```

    Update `src/App.tsx` — configure router with AuthProvider wrapping all routes:

    ```typescript
    // src/App.tsx
    import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
    import { AuthProvider } from './context/AuthContext'
    import { ProtectedRoute } from './components/layout/ProtectedRoute'
    import LoginPage from './pages/Login'
    import SignupPage from './pages/Signup'

    // Dashboard is imported from 01-03 — use a placeholder if 01-03 runs in parallel
    // If 01-03 is not yet complete, create a temporary stub inline:
    const DashboardPlaceholder = () => <div>Dashboard coming soon (01-03)</div>

    function App() {
      return (
        <BrowserRouter>
          <AuthProvider>
            <Routes>
              <Route path="/login" element={<LoginPage />} />
              <Route path="/signup" element={<SignupPage />} />
              <Route
                path="/dashboard"
                element={
                  <ProtectedRoute>
                    <DashboardPlaceholder />
                  </ProtectedRoute>
                }
              />
              {/* Redirect root to dashboard — ProtectedRoute handles unauthenticated redirect to /login */}
              <Route path="/" element={<Navigate to="/dashboard" replace />} />
              {/* Catch-all for unknown routes */}
              <Route path="*" element={<Navigate to="/login" replace />} />
            </Routes>
          </AuthProvider>
        </BrowserRouter>
      )
    }

    export default App
    ```

    NOTE: When 01-03 is complete, replace DashboardPlaceholder with the real Dashboard import.

    Update `src/main.tsx` — ensure it just renders App (no changes needed if it already does, but verify React.StrictMode is wrapping App):

    ```typescript
    // src/main.tsx
    import { StrictMode } from 'react'
    import { createRoot } from 'react-dom/client'
    import './index.css'
    import App from './App'

    createRoot(document.getElementById('root')!).render(
      <StrictMode>
        <App />
      </StrictMode>
    )
    ```
  </action>
  <verify>
    1. `npm run dev` — app starts, no console errors
    2. Visit http://localhost:5173 — redirected to /dashboard — then /login (unauthenticated)
    3. Visit http://localhost:5173/signup — signup form renders
    4. Create a test account (e.g., test@example.com, password12345) — redirected to /dashboard on success
    5. Verify test@example.com appears in Supabase Dashboard → Authentication → Users
    6. Verify a row exists in Supabase Dashboard → Table Editor → users (profile auto-created by trigger)
    7. Refresh the browser on /dashboard — stays on /dashboard (session persists, AUTH-03)
    8. Click Log Out — redirected to /login immediately (AUTH-04)
    9. Manually navigate to /dashboard after logout — redirected back to /login
    10. Log in with same credentials — redirected to /dashboard (AUTH-02)
    11. `npx tsc --noEmit` — no TypeScript errors
  </verify>
  <done>
    - Signup creates account, auto-creates public.users profile, redirects to /dashboard (AUTH-01)
    - Login authenticates and redirects to /dashboard (AUTH-02)
    - Browser refresh on /dashboard stays authenticated — no re-login required (AUTH-03)
    - Logout redirects to /login immediately and /dashboard is inaccessible without re-login (AUTH-04)
    - Unauthenticated access to /dashboard redirects to /login
    - Auth errors displayed inline on forms (wrong password, existing email)
    - TypeScript compiles cleanly with no errors
  </done>
</task>

</tasks>

<verification>
Full auth flow verification after both tasks complete:

1. `npm run build` — production build succeeds with no TypeScript errors
2. `npm run dev` and complete the signup → persist → logout → login cycle:
   a. Visit /signup, create account → should land on /dashboard
   b. Refresh browser → should stay on /dashboard (AUTH-03 verified)
   c. Click logout → should land on /login (AUTH-04 verified)
   d. Visit /dashboard directly → should redirect to /login (protected route works)
   e. Log in → should land on /dashboard (AUTH-02 verified)
3. In Supabase Dashboard, confirm the test user appears in Authentication → Users and has a matching row in Table Editor → users (DATA-02 partial — profile persists)
4. Test invalid credentials: wrong password on login → inline error appears, no crash
</verification>

<success_criteria>
- Signup, login, session persistence, and logout all work as described in Phase 1 success criteria 1-3
- No user is ever shown a blank screen or uncaught error during the auth flow
- ProtectedRoute correctly blocks unauthenticated access
- TypeScript compiles with zero errors
- Supabase test user and profile row exist after signup
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-foundation/01-02-SUMMARY.md` documenting:
- Confirmed package versions installed
- Any deviations from the plan (e.g., different file names, different loading state implementation)
- Whether the DashboardPlaceholder is still in App.tsx or replaced by the real Dashboard (01-03)
- Any Supabase auth errors encountered and how they were resolved
</output>
